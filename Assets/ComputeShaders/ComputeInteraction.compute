// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel DrawCircle

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture


struct Particle
{
    float2 pos;
    float2 vel;
    float lifeTime;
    int isActive;
};

struct ParticleConnection
{
    int indexA;
    int indexB;
    float2 basePosition;
    float intensity;
};


ConsumeStructuredBuffer<int> particleIndexPool;
ConsumeStructuredBuffer<int> connectionIndexPool;

StructuredBuffer<Particle> particleSrc;
RWStructuredBuffer<Particle> particleDest;
StructuredBuffer<ParticleConnection> connectionSrc;
RWStructuredBuffer<ParticleConnection> connectionDest;

float2 center;
float radius;

[numthreads(1,1,1)]
void DrawCircle (uint3 id : SV_DispatchThreadID)
{
    
    Particle currentParticle;
    int currentIndex = particleIndexPool.Consume();
    Particle beginParticle;
    int beginIndex;
    currentParticle.pos = center + float2(radius,0.0);
    currentParticle.vel = 0.0;
    currentParticle.lifeTime = 10000.0;
    currentParticle.isActive = 1;
    particleDest[currentIndex] = currentParticle;
    beginParticle = currentParticle;
    beginIndex = currentIndex;
    
    for(int i = 1; i < 12; i++)
    {
        Particle nextParticle;
        int nextIndex;
        nextIndex = particleIndexPool.Consume();
        nextParticle.pos = center + float2(cos(6.28 * i /12.0),sin(6.28 * i /12.0)) * radius;
        nextParticle.vel = 0.0;
        nextParticle.lifeTime = 10000.0;
        nextParticle.isActive = 1;
        particleDest[nextIndex] = nextParticle;

        int connectionIndex = connectionIndexPool.Consume();
        ParticleConnection c;
        c.indexA = currentIndex;
        c.indexB = nextIndex;
        c.basePosition = nextParticle.pos - currentParticle.pos;
        c.intensity = 1.0;
        connectionDest[connectionIndex] = c;

        connectionIndex = connectionIndexPool.Consume();
        c.indexA = nextIndex;
        c.indexB = currentIndex;
        c.basePosition = currentParticle.pos - nextParticle.pos;
        c.intensity = 1.0;
        connectionDest[connectionIndex] = c;
        
        currentIndex = nextIndex;
        currentParticle = nextParticle;
    }

    int connectionIndex = connectionIndexPool.Consume();
    ParticleConnection c;
    c.indexA = beginIndex;
    c.indexB = currentIndex;
    c.basePosition = beginParticle.pos - currentParticle.pos;
    c.intensity = 1.0;
    connectionDest[connectionIndex] = c;

    connectionIndex = connectionIndexPool.Consume();
    c.indexA = currentIndex;
    c.indexB = beginIndex;
    c.basePosition = currentParticle.pos - beginParticle.pos;
    c.intensity = 1.0;
    connectionDest[connectionIndex] = c;

    
    
}
